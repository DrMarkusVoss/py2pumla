#!/usr/bin/python
"""Command Line Tool and PUMLA hook for processing
python files and producing PUMLA conformant
PlantUML models of it.
"""

__author__ = "Dr. Markus Voss (private person)"
__copyright__ = "(C) Copyright 2021 by Dr. Markus Voss (private person)"
__license__ = "GPL"
__version__ = "0.1.0"
__maintainer__ = "Dr. Markus Voss (private person)"
__status__ = "Development"

import sys
import os
from importlib.util import spec_from_file_location, module_from_spec
import inspect


def identifyMe():
    """ information about the executed command """
    print("pytopumla v0.1 - by Dr. Markus Voss")

def isInBlacklist(path, blacklist):
    """ check whether the given path is contained in the
        given blacklist list."""
    retval = False
    for e in blacklist:
        if (e in path):
            retval = True
    return retval

def createClassPUMLCode(classelement, targetpath):
    #print(classelement)
    print("class-el-name = " + classelement.__name__)
    print("class-el_mod = " + classelement.__module__)
    # ltw = lines to write
    ltw = "'PUMLAMR\n@startuml\n\n"
    ce_name = classelement.__name__
    ce_alias = ce_name.lower() + "Class"
    ltw = ltw + "!if ($PUMVarShowBody)\n"
    ltw = ltw + 'class "'+ ce_name + '" as ' + ce_alias + ' <<Python>> { \n'
    #print(dir(classelement))
    #print(classelement.__dict__)
    for me in dir(classelement):
        if ((not ("__" in me)) or (me == "__init__")):
            me_name = me
            #print(me)
            me_raw = classelement.__dict__[me]
            me_args = me_raw.__code__.co_varnames
            ltw = ltw + "\t+" + me_name + str(me_args).replace("'", "").replace(",)", ")") + "\n"

    ltw = ltw + "!endif\n"
    ltw = ltw + "}\n\n"

    ltw = ltw + "!if ($PUMVarShowDescr)\n"
    ltw = ltw + "note bottom of " + ce_alias + "\n"
    ltw = ltw + "\tautomatically generated by py2pumla.\n\n"
    ltw = ltw + "\tPython Doc String:\n"
    ltw = ltw + "\t" + str(classelement.__doc__) + "\n"
    ltw = ltw + "end note\n"
    ltw = ltw + "!endif\n"


    ltw = ltw + "\n@enduml\n"
    print(ltw)

    # write file here

    return ce_alias

def createModulePUMLCore(module, filename, list_of_elementalias, mymod_func, mymod_uses, targetpath):
    ltw = "'PUMLAMR\n@startuml\n\n"
    me_name = module.__name__
    me_alias = me_name.lower() + "Module"
    ltw = ltw + "!if ($PUMVarShowBody)\n"
    ltw = ltw + 'package "' + filename + '" as ' + me_alias + ' <<Python>> { \n'
    if not(mymod_func == ""):
        ltw = ltw + '\tclass ModuleFunctions <<Python>> {\n'
        ltw = ltw + mymod_func
        ltw = ltw + '\t}\n\n'
    for e in list_of_elementalias:
        ltw = ltw + "\tPUMLAPutInternalElement(" + e + ")\n"

    ltw = ltw + "}\n\n"

    ltw = ltw + "!if ($PUMVarShowDescr)\n"
    ltw = ltw + "note bottom of " + me_alias + "\n"
    ltw = ltw + "\tautomatically generated by py2pumla.\n\n"
    ltw = ltw + "\tPython Doc String:\n"
    ltw = ltw + "\t" + str(module.__doc__) + "\n"
    ltw = ltw + "end note\n"
    ltw = ltw + "!endif\n"
    ltw = ltw + "@enduml\n\n"

    print(ltw)
    # write file here mode

    # write file here mymod_uses



def py2pumla(fname, targetpath):
    basename = os.path.basename(fname)
    fullname = os.path.abspath(fname)
    print("basename = " + basename)
    modulename = basename.split(".")[0]
    print("modulename = " + modulename)
    print(os.path.abspath(os.path.curdir))
    sys.path.append(os.path.abspath(os.path.curdir))
    sys.path.append(os.path.abspath(os.path.dirname(fullname)))
    #os.chdir(os.path.commonpath()fullname.)
    spec = spec_from_file_location(modulename, fullname)
    mod = module_from_spec(spec)
    spec.loader.exec_module(mod)
    d = mod.__dict__
    keys = d.keys()
    mod_els = []
    module_element_alias = []
    if (inspect.ismodule(mod)):
        print(mod)
        print("... is a module")
    for e in keys:
        if not "__" in e:
            mod_els.append(d[e])

    #print(mod_els)

    mymod_uses = ""
    mymod_func = ""
    for me in mod_els:
        #print(me.__dict__.keys())
        #print(dir(me))
        if (inspect.isclass(me)):
            #print("Class: ")
            #print(me)
            cl_alias = createClassPUMLCode(me, targetpath)
            module_element_alias.append(cl_alias)
        elif (inspect.ismodule(me)):
            print(me)
            print("... is a module used.")

        elif (inspect.isfunction(me)):
            print(me)
            if (me.__code__.co_filename == mod.__file__):
                print("... is my function.")
                me_name = me.__name__
                me_args = me.__code__.co_varnames
                mymod_func = mymod_func + "\t\t+" + str(me_name) + str(me_args).replace("'", "").replace(",)", ")") + "\n"
            else:
                print("... is a function from: " + str(me.__module__))

                mod_alias = str(mod.__name__).lower() + "Module"
                relalias = "REL#" + mod_alias + "_USES_" + str(me.__name__) +"_FROM_" + str(me.__module__)
                mymod_uses = mymod_uses + 'PUMLARelation(' + mod_alias + ', "..>", ' + str(me.__module__) + ', "uses: ' + str(me.__name__) + '", "' + relalias + '")\n'

    createModulePUMLCore(mod, fname, module_element_alias, mymod_func, mymod_uses, targetpath)

    print(mymod_uses)




def findPythonFiles(path):
    """" find all pumla files in given path """
    pythonfiles = []
    blacklist = []

    blacklistfilename = path + "/pumla_blacklist.txt"
    #print(blacklistfilename)
    if (os.path.isfile(blacklistfilename)):
        #print("blacklist found\n")
        file = open(blacklistfilename)
        text = file.read()
        #print(text)
        file.close()
        for li in text.split():
            blacklist.append(path + li.strip("."))
        #print(blacklist)
    # walk through the file and folder structure
    # and put all PUMLA files into a list
    for dirpath, dirs, files in os.walk(path):
        for filename in files:
            if (not(isInBlacklist(dirpath, blacklist))):
                #print(dirpath)
                fname = os.path.join(dirpath, filename)
                # a PUMLA file must end with '.puml' (see Modelling Guideline)
                if fname.endswith('.py'):
                    pythonfiles.append(fname)

    return pythonfiles


def parseSysArg(sysarg):
    """ parses the given command line arguments """
    # no parameter - default behaviour: show all pumla files in subdirs
    if (len(sysarg) == 1):
        pass
    elif (len(sysarg) == 2):
        pyfiles = findPythonFiles(sysarg[1])
        pumla_gen_dir = sysarg[1] + "/_generated_pumla"
        if (not(os.path.exists(pumla_gen_dir))):
            os.mkdir(pumla_gen_dir)
        for e in pyfiles:
            py2pumla(e, pumla_gen_dir)

    else:
        print("too much arguments... only one path to search for python files, please.")




if __name__ == "__main__":
    identifyMe()
    parseSysArg(sys.argv)